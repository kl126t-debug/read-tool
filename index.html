<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>åŒè¯­æœ—è¯»å™¨</title>
  
  <!-- PWA Meta Tags -->
  <meta name="description" content="ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„åŒè¯­æœ—è¯»å™¨PWAåº”ç”¨">
  <meta name="theme-color" content="#2196F3">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="åŒè¯­æœ—è¯»å™¨">
  
  <!-- Manifest -->
  <link rel="manifest" href="manifest.json">
  
  <!-- Icons -->
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512x512.png">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">
  <script src="https://sdk.cloud.chivox.com/chivoxsdk-js/v6.1/chivox.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    textarea {
      width: 90vw;
      height: 150px;
      margin-bottom: 1em;
    }
    #sentenceBox {
      width: 90vw;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 1em;
      margin-bottom: 1em;
      font-size: 1.2em;
    }
    .sentence {
      margin: 0.5em 0;
    }
    .highlight {
      background-color: #ffffcc;
    }
    #bookmarks {
      margin-top: 1em;
      border-top: 1px solid #ccc;
      padding-top: 1em;
      width: 90vw;
    }
    #recentFiles {
      margin: 1em 0;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 1em;
      width: 90vw;
      background-color: #f9f9f9;
    }
    .recent-file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5em;
      margin: 0.3em 0;
      background-color: white;
      border: 1px solid #eee;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .recent-file-item:hover {
      background-color: #e3f2fd;
    }
    .file-info {
      flex: 1;
    }
    .file-name {
      font-weight: bold;
      color: #2196F3;
    }
    .file-position {
      font-size: 0.9em;
      color: #666;
    }
    .file-date {
      font-size: 0.8em;
      color: #999;
    }
    .delete-file {
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 0.2em 0.5em;
      cursor: pointer;
      font-size: 0.8em;
    }
    .delete-file:hover {
      background: #cc0000;
    }
    button {
      margin: 5px;
      padding: 0.5em 1em;
      font-size: 1em;
    }
    input[type="range"] {
      width: 90vw;
    }
    #result { white-space: pre-wrap; background: #f0f0f0; padding: 10px; margin-top: 20px; }
  </style>
</head>
<body>
	  

  <h2>ğŸ“– æœ—è¯»å™¨</h2>
  <input type="file" id="fileInput" accept=".txt"><br>
  
  <!-- æœ€è¿‘æ‰“å¼€çš„æ–‡ä»¶åˆ—è¡¨ -->
  <div id="recentFiles" style="display: none;">
    <strong>ğŸ“‚ æœ€è¿‘æ‰“å¼€çš„æ–‡ä»¶ï¼š</strong>
    <div id="recentFilesList"></div>
  </div>
  <div id="result">æµ‹è¯„ç»“æœå°†åœ¨æ­¤æ˜¾ç¤º</div>
  <div id="wordTableContainer"></div>

  <button id="bookmarkBtn">â­ æ·»åŠ ä¹¦ç­¾</button>

  <div>
    <label for="speedRange">é€Ÿåº¦:</label>
    <input type="range" id="speedRange" min="0.5" max="2" step="0.1" value="1">
  </div>
  <div>
    <label for="volumeRange">éŸ³é‡:</label>
    <input type="range" id="volumeRange" min="0" max="1" step="0.1" value="1">
  </div>
  <div>
    <label for="progressRange">è¿›åº¦:</label>
    <input type="range" id="progressRange" min="0" value="0" step="1">
    <span id="progressLabel">ç¬¬ 0 å¥</span>
  </div>

  <div id="sentenceBox"></div>

  <div id="bookmarks">
    <strong>ğŸ”– ä¹¦ç­¾åˆ—è¡¨ï¼š</strong>
    <ul id="bookmarkList"></ul>
  </div>

  <script>
    let sentences = [];
    let currentIndex = 0;
    let mIndex=null;
    let reading = false;
    let readSpeed = 1;
    let volume = 1;
    let bookmarkedIndices = [];
    let currentFileName = '';
    let currentFileContent = '';
	  let recorder = null;
    let isRecording = false;
let thisSentence="";
const debounceDelay = 100;
    let lastKeyTime = 0;
 let client =null;
    const longPressThreshold = 300;
    let keyDownTime = 0;
    let longPressTimer = null;
    let isLongPress = false;
    var synth = window.speechSynthesis;
    
    var voices = speechSynthesis.getVoices();
   
    const fileInput = document.getElementById('fileInput');
    
    const bookmarkBtn = document.getElementById('bookmarkBtn');
    const speedRange = document.getElementById('speedRange');
    const volumeRange = document.getElementById('volumeRange');
    const progressRange = document.getElementById('progressRange');
    const progressLabel = document.getElementById('progressLabel');
    const sentenceBox = document.getElementById('sentenceBox');
    const bookmarkList = document.getElementById('bookmarkList');
    const recentFiles = document.getElementById('recentFiles');
    const recentFilesList = document.getElementById('recentFilesList');
const resultDiv = document.getElementById('result');

function initRecorder() {
      recorder = new Html5Recorder({
        appKey: "16551899080000a5", //1575874525000026 ï¼ŒsecretKey = "8c80157c9bcc5b3187af1e4775e6a6b1"
        sigurl: "https://collection.91tszx.com/api/Contact/JSSDKsign",
        userId: "gabby_user_001", // å¯è‡ªå®šä¹‰ç”¨æˆ·æ ‡è¯†
        onInit: () => {
          console.log("âœ… SDK åˆå§‹åŒ–æˆåŠŸ");
          
        },
        onError: err => {
          console.error("âŒ SDK åˆå§‹åŒ–å¤±è´¥", err);
          resultDiv.textContent = "åˆå§‹åŒ–å¤±è´¥ï¼š" + JSON.stringify(err);
        }
      });
    }
    
    // æ–‡ä»¶å†å²è®°å½•ç®¡ç†
    const MAX_RECENT_FILES = 5;
    
    // è·å–æœ€è¿‘æ–‡ä»¶åˆ—è¡¨
    function getRecentFiles() {
      const stored = localStorage.getItem('recentFiles');
      return stored ? JSON.parse(stored) : [];
    }
    
    // ä¿å­˜æœ€è¿‘æ–‡ä»¶åˆ—è¡¨
    function saveRecentFiles(files) {
      localStorage.setItem('recentFiles', JSON.stringify(files));
    }
    
    // æ·»åŠ æ–‡ä»¶åˆ°æœ€è¿‘åˆ—è¡¨
    function addToRecentFiles(fileName, content, position = 0) {
      let recentFiles = getRecentFiles();
      
      // ç§»é™¤å·²å­˜åœ¨çš„åŒåæ–‡ä»¶
      recentFiles = recentFiles.filter(file => file.name !== fileName);
      
      // æ·»åŠ æ–°æ–‡ä»¶åˆ°å¼€å¤´
      recentFiles.unshift({
        name: fileName,
        content: content,
        position: position,
        timestamp: Date.now()
      });
      
      // é™åˆ¶æœ€å¤§æ•°é‡
      if (recentFiles.length > MAX_RECENT_FILES) {
        recentFiles = recentFiles.slice(0, MAX_RECENT_FILES);
      }
      
      saveRecentFiles(recentFiles);
      renderRecentFiles();
    }
    
    // æ›´æ–°æ–‡ä»¶çš„æœ—è¯»ä½ç½®
    function updateFilePosition(fileName, position) {
      let recentFiles = getRecentFiles();
      const fileIndex = recentFiles.findIndex(file => file.name === fileName);
      
      if (fileIndex !== -1) {
        recentFiles[fileIndex].position = position;
        recentFiles[fileIndex].timestamp = Date.now();
        saveRecentFiles(recentFiles);
      }
    }
    
    // ä»æœ€è¿‘åˆ—è¡¨åˆ é™¤æ–‡ä»¶
    function removeFromRecentFiles(fileName) {
      let recentFiles = getRecentFiles();
      recentFiles = recentFiles.filter(file => file.name !== fileName);
      saveRecentFiles(recentFiles);
      renderRecentFiles();
    }
    
    // æ¸²æŸ“æœ€è¿‘æ–‡ä»¶åˆ—è¡¨
    function renderRecentFiles() {
      const recentFiles = getRecentFiles();
      
      if (recentFiles.length === 0) {
        document.getElementById('recentFiles').style.display = 'none';
        return;
      }
      
      document.getElementById('recentFiles').style.display = 'block';
      recentFilesList.innerHTML = '';
      
      recentFiles.forEach(file => {
        const fileItem = document.createElement('div');
        fileItem.className = 'recent-file-item';
        
        const fileInfo = document.createElement('div');
        fileInfo.className = 'file-info';
        
        const fileName = document.createElement('div');
        fileName.className = 'file-name';
        fileName.textContent = file.name;
        
        const filePosition = document.createElement('div');
        filePosition.className = 'file-position';
        filePosition.textContent = `ä¸Šæ¬¡æœ—è¯»ä½ç½®: ç¬¬ ${file.position} å¥`;
        
        const fileDate = document.createElement('div');
        fileDate.className = 'file-date';
        fileDate.textContent = `æœ€åæ‰“å¼€: ${new Date(file.timestamp).toLocaleString()}`;
        
        fileInfo.appendChild(fileName);
        fileInfo.appendChild(filePosition);
        fileInfo.appendChild(fileDate);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-file';
        deleteBtn.textContent = 'åˆ é™¤';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          removeFromRecentFiles(file.name);
        };
        
        fileItem.appendChild(fileInfo);
        fileItem.appendChild(deleteBtn);
        
        // ç‚¹å‡»æ–‡ä»¶é¡¹åŠ è½½æ–‡ä»¶
        fileItem.onclick = () => {
          loadFileFromHistory(file);
        };
        
        recentFilesList.appendChild(fileItem);
      });
    }
    
    // ä»å†å²è®°å½•åŠ è½½æ–‡ä»¶
    function loadFileFromHistory(fileData) {
      currentFileName = fileData.name;
      currentFileContent = fileData.content;
      sentences = fileData.content.split(/\r?\n/).filter(s => s.trim() !== '');
      currentIndex = fileData.position;
      progressRange.max = sentences.length - 1;
      progressRange.value = currentIndex;
      renderSentences();
      highlightCurrent();
      
      // æ¸…ç©ºæ–‡ä»¶è¾“å…¥æ¡†
      fileInput.value = '';
    }

    speedRange.oninput = () => readSpeed = parseFloat(speedRange.value);
    volumeRange.oninput = () => volume = parseFloat(volumeRange.value);

    fileInput.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target.result;
        currentFileName = file.name;
        currentFileContent = text;
        sentences = text.split(/\r?\n/).filter(s => s.trim() !== '');
        currentIndex = 0;
        progressRange.max = sentences.length - 1;
        progressRange.value = 0;
        renderSentences();
        
        // æ·»åŠ åˆ°æœ€è¿‘æ–‡ä»¶åˆ—è¡¨
        addToRecentFiles(file.name, text, 0);
      };
      reader.readAsText(file);
    };

    function renderSentences() {
      sentenceBox.innerHTML = '';
      sentences.forEach((sentence, i) => {
        const div = document.createElement('div');
        div.className = 'sentence';
        div.textContent = sentence;
        div.dataset.index = i;
        sentenceBox.appendChild(div);
      });
    }

    function highlightCurrent() {
      document.querySelectorAll('.sentence').forEach((el, idx) => {
        el.classList.toggle('highlight', idx === currentIndex);
      });
      progressLabel.textContent = `ç¬¬ ${currentIndex} å¥`;
      progressRange.value = currentIndex;
      const currentEl = document.querySelector(`.sentence[data-index="${currentIndex}"]`);
      if (currentEl) {
        currentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
      
      // æ›´æ–°å½“å‰æ–‡ä»¶çš„æœ—è¯»ä½ç½®
      if (currentFileName) {
        updateFilePosition(currentFileName, currentIndex);
      }
    }

    progressRange.oninput = () => {
      currentIndex = parseInt(progressRange.value);
      reading = true;
      speechSynthesis.cancel();
      readSentence();
    };

    

    bookmarkBtn.onclick = () => {
      if (!bookmarkedIndices.includes(currentIndex)) {
        bookmarkedIndices.push(currentIndex);
        const li = document.createElement('li');
        li.textContent = `ç¬¬ ${currentIndex} å¥ï¼š${sentences[currentIndex]}`;
        li.style.cursor = 'pointer';
        li.onclick = () => {
          currentIndex = parseInt(li.textContent.split('å¥')[0].replace('ç¬¬', ''));
          readSentence();
        };
        bookmarkList.appendChild(li);
      }
    };

    function readSentence() {
    	let tempIdx=currentIndex;
    	if(mIndex) currentIndex=mIndex;
      if (currentIndex >= sentences.length || !reading){mIndex=null; return;} 
      
      const utterance = new SpeechSynthesisUtterance(sentences[currentIndex]);
      currentIndex=tempIdx;
      utterance.rate = readSpeed;
      utterance.volume = volume;
      /*utterance.onend = () => {
        currentIndex++;
        highlightCurrent();
        if (reading && currentIndex < sentences.length) {
          setTimeout(() => readSentence(), 400);
        }
      };*/
      mIndex=null;
      highlightCurrent();
      //speechSynthesis.cancel();
      //Put this on the play button
    synth.resume();
    synth.speak(utterance);
      //speechSynthesis.speak(utterance);
    }

      function startRbtn(){
      	 thisSentence = sentences[Math.max(0, currentIndex - 1)];

      if (!thisSentence) {
        
        return;
      }

      if (!recorder) {
        
        return;
      }

      isRecording = true;
      
      resultDiv.textContent = "ğŸ™ æ­£åœ¨å½•éŸ³ï¼Œè¯·æœ—è¯»å¥å­...";

      recorder.record({
        serverParams: {
          coreType: "en.sent.pron",
          refText: thisSentence,
          rank: 100,
          attachAudioUrl: 1
        },
        duration: 10000, // æœ€å¤§å½•éŸ³æ—¶é•¿ï¼ˆæ¯«ç§’ï¼‰
        onScore: result => {
         // console.log("âœ… æµ‹è¯„åŸå§‹ JSONï¼š", result);
          resultDiv.textContent = formatResult(result);
        },
        onScoreError: err => {
          console.error("âŒ æµ‹è¯„å¤±è´¥", err);
          resultDiv.textContent = "æµ‹è¯„å¤±è´¥ï¼š" + JSON.stringify(err);
        },
        onStart: () => {
         console.log("ğŸ“¤ å½•éŸ³å¼€å§‹ï¼Œæ­£åœ¨å¤„ç†...");
        },
        onStop: () => {
          console.log("ğŸ“¤ å½•éŸ³ç»“æŸï¼Œæ­£åœ¨å¤„ç†...");
        }
        });
    }
       function stopRbtn(){
       	if (isRecording && recorder) {
              recorder.stopRecord(); // âœ… æ­£ç¡®çš„åœæ­¢æ–¹æ³•
              isRecording = false;
           }
      }
    
function extractHitWordGroups(words) {
  if (!Array.isArray(words)) return [];

  // Step 1: æ‰¾å‡ºå‘½ä¸­çš„è¯åŠå…¶ç´¢å¼•
  const hits = words
    .map((word, index) => {
      const isHit = word.score > 0 || (word.rec && word.rec.trim() !== "#");
      return isHit ? { index, text: word.lab } : null;
    })
    .filter(Boolean);

  if (hits.length === 0) return [];

  // Step 2: æŒ‰ç´¢å¼•åˆ†ç»„è¿ç»­çš„å‘½ä¸­è¯
  const groups = [];
  let currentGroup = [hits[0]];

  for (let i = 1; i < hits.length; i++) {
    const prev = hits[i - 1];
    const curr = hits[i];
    if (curr.index === prev.index + 1) {
      currentGroup.push(curr);
    } else {
      groups.push(currentGroup);
      currentGroup = [curr];
    }
  }
  groups.push(currentGroup); // åŠ å…¥æœ€åä¸€ç»„

  // Step 3: è¾“å‡ºæ¯ç»„å‘½ä¸­è¯æ–‡æœ¬åˆ—è¡¨
  return groups.map(group => group.map(item => item.text));
}

    // æ ¼å¼åŒ–æµ‹è¯„ç»“æœ
    function formatResult(result) {
  if (!result || !result.result || !result.result.details) {
    return "æ— æœ‰æ•ˆç»“æœ";
  }

  const { overall, fluency, integrity, accuracy } = result.result;
  const words = result.result.details;
  const matchlist=extractHitWordGroups(words);
  let mpiece='';
  if (matchlist.length===1){
  	mpiece=matchlist[0].join(" ");
  }
  const queryText=`${mpiece} åœ¨è¿™å¥è¯ä¸­æ˜¯ä»€ä¹ˆæ„æ€ï¼š${thisSentence}`;
  let reply;
  client.sendMessage(queryText).then(result=>{
  	 reply=result;
  	}
);
  

  let summary = `âœ… æµ‹è¯„å®Œæˆï¼š
${reply}
`;

  let tableHTML = `
    <table border="1" cellpadding="6" style="margin-top:10px; border-collapse: collapse; width:100%;">
      <thead>
        <tr style="background:#eee;">
          <th>åºå·</th>
          <th>å•è¯</th>
          <th>å¾—åˆ†</th>
          <th>çº æ­£å»ºè®®</th>
        </tr>
      </thead>
      <tbody>
  `;
words.forEach((word, index) => {
    

    tableHTML += `
      <tr>
        <td>${index + 1}</td>
        <td>${word.lab}</td>
        <td>${word.score}</td>
        <td>${word.rec || "â€”"}</td>
      </tr>
    `;
        
   });

  tableHTML += `</tbody></table>`;

  document.getElementById("result").textContent = summary;
  document.getElementById("wordTableContainer").innerHTML = tableHTML;

  return summary;
}     

 class XiaobaiChatClient {
  constructor(apiKey, botId = 200006, modelId = "xiaobaiOSS") {
    this.apiKey = apiKey;
    this.botId = botId;
    this.modelId = modelId;
    this.deviceId = `${crypto.randomUUID().replace(/-/g, "")}_${Date.now()}_${Math.floor(Math.random() * 1000000)}`;
    this.token = "";
    this.userId = "";
    this.conversationId = "";
  }

  async generateSignature(payloadStr) {
    const mistiming = Number(localStorage.getItem("mistiming")) || 0;
    const xDate = new Date(Date.now() + mistiming).toUTCString();
    const digestBuffer = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(payloadStr));
    const digestBase64 = btoa(String.fromCharCode(...new Uint8Array(digestBuffer)));
    const digestHeader = `SHA-256=${digestBase64}`;
    const stringToSign = `x-date: ${xDate}\ndigest: ${digestHeader}`;
    const keyBuffer = new TextEncoder().encode(this.apiKey);
    const cryptoKey = await crypto.subtle.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-1" }, false, ["sign"]);
    const signatureBuffer = await crypto.subtle.sign("HMAC", cryptoKey, new TextEncoder().encode(stringToSign));
    const signatureBase64 = btoa(String.fromCharCode(...new Uint8Array(signatureBuffer)));
    const authorizationHeader = `hmac username="web.1.0.beta", algorithm="hmac-sha1", headers="x-date digest", signature="${signatureBase64}"`;

    return { xDate, digestHeader, authorizationHeader };
  }

  async init() {
    const payload = {
      deviceId: this.deviceId,
      device: "Edge",
      client: "tourist",
      phone: this.deviceId,
      code: this.deviceId,
      extraInfo: { url: "https://www.wenxiaobai.com/" }
    };
    const payloadStr = JSON.stringify(payload);
    const { xDate, digestHeader, authorizationHeader } = await this.generateSignature(payloadStr);

    const headers = {
      "Content-Type": "application/json",
      "Authorization": authorizationHeader,
      "Digest": digestHeader,
      "x-date": xDate,
      "X-Yuanshi-AppName": "wenxiaobai",
      "X-Yuanshi-DeviceId": this.deviceId,
      "X-Yuanshi-Platform": "web"
    };

    const res = await fetch("https://api-bj.wenxiaobai.com/api/v1.0/user/sessions", {
      method: "POST",
      headers,
      body: payloadStr
    });
    const data = await res.json();
    this.token = data?.data?.token || "";
    this.userId = data?.data?.user?.id || "";

    await this.createConversation();
  }

  async createConversation() {
    const url = `https://api-bj.wenxiaobai.com/api/v1.0/core/conversations/users/${this.userId}/bots/${this.botId}/conversation`;
    const payloadStr = JSON.stringify({ visitorId: this.deviceId });
    const { xDate, digestHeader, authorizationHeader } = await this.generateSignature(payloadStr);

    const headers = {
      "Content-Type": "application/json",
      "Authorization": authorizationHeader,
      "Digest": digestHeader,
      "x-date": xDate,
      "X-Yuanshi-Authorization": `Bearer ${this.token}`,
      "X-Yuanshi-AppName": "wenxiaobai",
      "X-Yuanshi-DeviceId": this.deviceId,
      "X-Yuanshi-Platform": "web"
    };

    const res = await fetch(url, {
      method: "POST",
      headers,
      body: payloadStr
    });
    const data = await res.json();
    this.conversationId = data?.data || "";
  }

  async sendMessage(query) {
    const body = {
      userId: this.userId,
      botAlias: "custom",
      query,
      isRetry: false,
      breakingStrategy: 0,
      isNewConversation: true,
      isAnonymousChat: false,
      mediaInfos: [],
      turnIndex: 0,
      rewriteQuery: "",
      conversationId: this.conversationId,
      attachmentInfo: { url: { infoList: [] } },
      inputWay: "proactive",
      agentId: this.botId,
      modelId: this.modelId,
      aiAbility: { id: "" },
      abilities: [],
      pureQuery: "",
      isPublic: 0
    };
    const payloadStr = JSON.stringify(body);
    const { xDate, digestHeader, authorizationHeader } = await this.generateSignature(payloadStr);

    const headers = {
      "Content-Type": "application/json",
      "Accept": "text/event-stream, application/json, text/event-stream",
      "Authorization": authorizationHeader,
      "Digest": digestHeader,
      "x-date": xDate,
      "X-Yuanshi-AppName": "wenxiaobai",
      "X-Yuanshi-Authorization": `Bearer ${this.token}`,
      "X-Yuanshi-DeviceId": this.deviceId,
      "X-Yuanshi-Platform": "web"
    };

    const res = await fetch("https://api-bj.wenxiaobai.com/api/v1.0/core/conversation/chat/v3", {
      method: "POST",
      headers,
      body: payloadStr
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder("utf-8");
    let finalText = "";
    let isThinking = false;

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      const chunk = decoder.decode(value, { stream: true });
      const lines = chunk.split("\n").map(line => line.trim()).filter(Boolean);
      for (const line of lines) {
        const content = this.extractContent(line);
        if (content && typeof content === 'string') {
          if (content.startsWith("```ys_think")) {
            isThinking = true;
          } else if (content.includes("\n<end>å·²æ·±åº¦æ€è€ƒ")) {
            isThinking = false;
          } else if (!isThinking) {
            finalText += content;
          }
        }
      }
    }

    return this.md2tts(finalText);
  }

  extractContent(line) {
    const raw = line.startsWith("data:") ? line.slice(5).trim() : line.trim();
    try {
      const json = JSON.parse(raw);
      return json?.content || null;
    } catch {
      const match = raw.match(/"content"\s*:\s*"([^"]*)/);
      return match ? match[1] : null;
    }
  }

  md2tts(md) {
    const html = marked.parse(md);
    const div = document.createElement("div");
    div.innerHTML = html;
    div.querySelectorAll("script,style,noscript,svg,canvas").forEach(n => n.remove());
    div.querySelectorAll("pre,code").forEach(n => n.innerText = n.innerText.replace(/\n+/g, " "));
    div.querySelectorAll("table").forEach(table => {
      const lines = Array.from(table.rows).map(row =>
        Array.from(row.cells).map(cell => cell.innerText.trim()).join("ï¼Œ")
      );
      table.replaceWith(lines.join("ï¼›"));
    });
    div.querySelectorAll("img").forEach(img => img.replaceWith(img.alt ? `[${img.alt}]` : ""));
    div.querySelectorAll("a").forEach(a => a.replaceWith(a.innerText));
    return div.innerText.replace(/\s+/g, " ").replace(/([ã€‚ï¼ï¼Ÿï¼›ï¼Œ\.])\s*([ã€‚ï¼ï¼Ÿï¼›ï¼Œ\.])/g, "$1").trim();
  }
}
      

        
      

    document.addEventListener('keyup', (e) => {
      if (e.key === '0') {
        const now = Date.now();
        lastKeyTime=now;
        const pressDuration = now - keyDownTime;
        

        if(longPressTimer) clearTimeout(longPressTimer);
        longPressTimer=null;

        if (!isLongPress && pressDuration < longPressThreshold) {
          if (!speechSynthesis.speaking ) {
			reading = true;
			  speechSynthesis.cancel();
			  readSentence();
		   } else {
			reading = false;
		    synth.pause();
		    return; // ç‰¹æ®Šå¤„ç†å®Œå°±è¿”å›ï¼Œä¸è§¦å‘æœ—è¯»é€»è¾‘
		   }
        }else{
        	isLongPress = false;
        	stopRbtn();
        }
       
      }
    });    
		
document.addEventListener('keydown',  (e)=> {
  if (e.repeat) return;

    const now = Date.now();
      if (now - lastKeyTime < debounceDelay) return;
         lastKeyTime = now;
  if (!sentences.length) return;
  switch (e.key) {
    case 'Enter': 
      e.preventDefault(); // å¦‚æœä½ ä¸å¸Œæœ›è§¦å‘é»˜è®¤è¡Œä¸ºï¼ˆå¦‚æäº¤è¡¨å•ï¼‰
      
      currentIndex = Math.min(sentences.length - 1, currentIndex + 2);
      
      break;
  
    case '1':
      mIndex = Math.min(sentences.length - 1, currentIndex + 1);
      break;
    case '2':
      mIndex = Math.max(0, currentIndex - 1);
      break;
    case '3':
      mIndex = Math.max(0, currentIndex - 2);
      break;
    case '.':
      currentIndex = Math.max(0, currentIndex - 1);
      break;
    case '0':
      e.preventDefault(); // é˜²æ­¢é¡µé¢æ»šåŠ¨
      keyDownTime = now;
      if(isLongPress ===false && longPressTimer===null){
	      longPressTimer = setTimeout(() => {
	        	
	              isLongPress = true;
	        	  startRbtn(); //å¼€å§‹å½•éŸ³
	            
	          
	        }, longPressThreshold);
      }

	  return;

      
    default:
      return; // éæŒ‡å®šé”®ä¸å¤„ç†
  }

  reading = true;
  speechSynthesis.cancel();
  readSentence();
});

    // é¡µé¢åˆå§‹åŒ–
    window.addEventListener('load', () => {
      // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒ Service Worker
	    if ('serviceWorker' in navigator) {
	      navigator.serviceWorker.register('sw.js')
	      .then(registration => {
	        console.log('Service Worker æ³¨å†ŒæˆåŠŸ:', registration);
	      })
	      .catch(error => {
	        console.error('Service Worker æ³¨å†Œå¤±è´¥:', error);
	      });
		  } else {
		    console.warn('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒ Service Worker');
		  }
	      // æ¸²æŸ“æœ€è¿‘æ–‡ä»¶åˆ—è¡¨
	      renderRecentFiles();
	      // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ– SDK
	     initRecorder();
	
		 client = new XiaobaiChatClient("TkoWuEN8cpDJubb7Zfwxln16NQDZIc8z");
		
		 client
              .init()
               .then(()=>console.log("xbåˆå§‹åŒ–å®Œæˆ"))
               .catch(e=>console.log ("xbåˆå§‹åŒ–å¤±è´¥ï¼š",e));


    });

    

  </script>
</body>
</html>
