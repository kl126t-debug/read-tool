<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>ÂèåËØ≠ÊúóËØªÂô®</title>
  
  <!-- PWA Meta Tags -->
  <meta name="description" content="‰∏Ä‰∏™ÂäüËÉΩÂº∫Â§ßÁöÑÂèåËØ≠ÊúóËØªÂô®PWAÂ∫îÁî®">
  <meta name="theme-color" content="#2196F3">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  <meta name="apple-mobile-web-app-title" content="ÂèåËØ≠ÊúóËØªÂô®">
  
  <!-- Manifest -->
  <link rel="manifest" href="manifest.json">
  
  <!-- Icons -->
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
  <link rel="icon" type="image/png" sizes="512x512" href="icons/icon-512x512.png">
  <link rel="apple-touch-icon" href="icons/icon-192x192.png">
  <script src="https://sdk.cloud.chivox.com/chivoxsdk-js/v6.1/chivox.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    textarea {
      width: 90vw;
      height: 150px;
      margin-bottom: 1em;
    }
    #sentenceBox {
      width: 90vw;
      max-height: 300px;
      overflow-y: auto;
      border: 1px solid #ccc;
      padding: 1em;
      margin-bottom: 1em;
      font-size: 1.2em;
    }
    .sentence {
      margin: 0.5em 0;
    }
    .highlight {
      background-color: #ffffcc;
    }
    #bookmarks {
      margin-top: 1em;
      border-top: 1px solid #ccc;
      padding-top: 1em;
      width: 90vw;
    }
    #recentFiles {
      margin: 1em 0;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 1em;
      width: 90vw;
      background-color: #f9f9f9;
    }
    .recent-file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5em;
      margin: 0.3em 0;
      background-color: white;
      border: 1px solid #eee;
      border-radius: 3px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .recent-file-item:hover {
      background-color: #e3f2fd;
    }
    .file-info {
      flex: 1;
    }
    .file-name {
      font-weight: bold;
      color: #2196F3;
    }
    .file-position {
      font-size: 0.9em;
      color: #666;
    }
    .file-date {
      font-size: 0.8em;
      color: #999;
    }
    .delete-file {
      background: #ff4444;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 0.2em 0.5em;
      cursor: pointer;
      font-size: 0.8em;
    }
    .delete-file:hover {
      background: #cc0000;
    }
    button {
      margin: 5px;
      padding: 0.5em 1em;
      font-size: 1em;
    }
    input[type="range"] {
      width: 90vw;
    }
    #result { white-space: pre-wrap; background: #f0f0f0; padding: 10px; margin-top: 20px; }
  </style>
</head>
<body>
	  

  <h2>üìñ ÊúóËØªÂô®</h2>
  <input type="file" id="fileInput" accept=".txt"><br>
  
  <!-- ÊúÄËøëÊâìÂºÄÁöÑÊñá‰ª∂ÂàóË°® -->
  <div id="recentFiles" style="display: none;">
    <strong>üìÇ ÊúÄËøëÊâìÂºÄÁöÑÊñá‰ª∂Ôºö</strong>
    <div id="recentFilesList"></div>
  </div>
  <div id="result">ÊµãËØÑÁªìÊûúÂ∞ÜÂú®Ê≠§ÊòæÁ§∫</div>
  <div id="wordTableContainer"></div>

  <button id="bookmarkBtn">‚≠ê Ê∑ªÂä†‰π¶Á≠æ</button>

  <div>
    <label for="speedRange">ÈÄüÂ∫¶:</label>
    <input type="range" id="speedRange" min="0.5" max="2" step="0.1" value="1">
  </div>
  <div>
    <label for="volumeRange">Èü≥Èáè:</label>
    <input type="range" id="volumeRange" min="0" max="1" step="0.1" value="1">
  </div>
  <div>
    <label for="progressRange">ËøõÂ∫¶:</label>
    <input type="range" id="progressRange" min="0" value="0" step="1">
    <span id="progressLabel">Á¨¨ 0 Âè•</span>
  </div>

  <div id="sentenceBox"></div>

  <div id="bookmarks">
    <strong>üîñ ‰π¶Á≠æÂàóË°®Ôºö</strong>
    <ul id="bookmarkList"></ul>
  </div>

  <script>
    let sentences = [];
    let currentIndex = 0;
    let mIndex=null;
   // let reading = false;
    let readSpeed = 1;
    let volume = 1;
    let bookmarkedIndices = [];
    let currentFileName = '';
    let currentFileContent = '';
	  let recorder = null;
    let isRecording = false;
let thisSentence=null;
const debounceDelay = 100;
    let lastKeyTime = 0;
 let client =null;
    const longPressThreshold = 300;
    let keyDownTime = 0;
    let longPressTimer = null;
    let isLongPress = false;
    var synth = window.speechSynthesis;
    
    var voices = speechSynthesis.getVoices();
   
    const fileInput = document.getElementById('fileInput');
    
    const bookmarkBtn = document.getElementById('bookmarkBtn');
    const speedRange = document.getElementById('speedRange');
    const volumeRange = document.getElementById('volumeRange');
    const progressRange = document.getElementById('progressRange');
    const progressLabel = document.getElementById('progressLabel');
    const sentenceBox = document.getElementById('sentenceBox');
    const bookmarkList = document.getElementById('bookmarkList');
    const recentFiles = document.getElementById('recentFiles');
    const recentFilesList = document.getElementById('recentFilesList');
const resultDiv = document.getElementById('result');

function initRecorder() {
      recorder = new Html5Recorder({
        appKey: "16551899080000a5", //1575874525000026 ÔºåsecretKey = "8c80157c9bcc5b3187af1e4775e6a6b1"
        sigurl: "https://collection.91tszx.com/api/Contact/JSSDKsign",
        userId: "gabby_user_001", // ÂèØËá™ÂÆö‰πâÁî®Êà∑Ê†áËØÜ
        onInit: () => {
          console.log("‚úÖ SDK ÂàùÂßãÂåñÊàêÂäü");
          
        },
        onError: err => {
          console.error("‚ùå SDK ÂàùÂßãÂåñÂ§±Ë¥•", err);
          resultDiv.textContent = "ÂàùÂßãÂåñÂ§±Ë¥•Ôºö" + JSON.stringify(err);
        }
      });
    }
    
    // Êñá‰ª∂ÂéÜÂè≤ËÆ∞ÂΩïÁÆ°ÁêÜ
    const MAX_RECENT_FILES = 5;
    
    // Ëé∑ÂèñÊúÄËøëÊñá‰ª∂ÂàóË°®
    function getRecentFiles() {
      const stored = localStorage.getItem('recentFiles');
      return stored ? JSON.parse(stored) : [];
    }
    
    // ‰øùÂ≠òÊúÄËøëÊñá‰ª∂ÂàóË°®
    function saveRecentFiles(files) {
      localStorage.setItem('recentFiles', JSON.stringify(files));
    }
    
    // Ê∑ªÂä†Êñá‰ª∂Âà∞ÊúÄËøëÂàóË°®
    function addToRecentFiles(fileName, content, position = 0) {
      let recentFiles = getRecentFiles();
      
      // ÁßªÈô§Â∑≤Â≠òÂú®ÁöÑÂêåÂêçÊñá‰ª∂
      recentFiles = recentFiles.filter(file => file.name !== fileName);
      
      // Ê∑ªÂä†Êñ∞Êñá‰ª∂Âà∞ÂºÄÂ§¥
      recentFiles.unshift({
        name: fileName,
        content: content,
        position: position,
        timestamp: Date.now()
      });
      
      // ÈôêÂà∂ÊúÄÂ§ßÊï∞Èáè
      if (recentFiles.length > MAX_RECENT_FILES) {
        recentFiles = recentFiles.slice(0, MAX_RECENT_FILES);
      }
      
      saveRecentFiles(recentFiles);
      renderRecentFiles();
    }
    
    // Êõ¥Êñ∞Êñá‰ª∂ÁöÑÊúóËØª‰ΩçÁΩÆ
    function updateFilePosition(fileName, position) {
      let recentFiles = getRecentFiles();
      const fileIndex = recentFiles.findIndex(file => file.name === fileName);
      
      if (fileIndex !== -1) {
        recentFiles[fileIndex].position = position;
        recentFiles[fileIndex].timestamp = Date.now();
        saveRecentFiles(recentFiles);
      }
    }
    
    // ‰ªéÊúÄËøëÂàóË°®Âà†Èô§Êñá‰ª∂
    function removeFromRecentFiles(fileName) {
      let recentFiles = getRecentFiles();
      recentFiles = recentFiles.filter(file => file.name !== fileName);
      saveRecentFiles(recentFiles);
      renderRecentFiles();
    }
    
    // Ê∏≤ÊüìÊúÄËøëÊñá‰ª∂ÂàóË°®
    function renderRecentFiles() {
      const recentFiles = getRecentFiles();
      
      if (recentFiles.length === 0) {
        document.getElementById('recentFiles').style.display = 'none';
        return;
      }
      
      document.getElementById('recentFiles').style.display = 'block';
      recentFilesList.innerHTML = '';
      
      recentFiles.forEach(file => {
        const fileItem = document.createElement('div');
        fileItem.className = 'recent-file-item';
        
        const fileInfo = document.createElement('div');
        fileInfo.className = 'file-info';
        
        const fileName = document.createElement('div');
        fileName.className = 'file-name';
        fileName.textContent = file.name;
        
        const filePosition = document.createElement('div');
        filePosition.className = 'file-position';
        filePosition.textContent = `‰∏äÊ¨°ÊúóËØª‰ΩçÁΩÆ: Á¨¨ ${file.position} Âè•`;
        
        const fileDate = document.createElement('div');
        fileDate.className = 'file-date';
        fileDate.textContent = `ÊúÄÂêéÊâìÂºÄ: ${new Date(file.timestamp).toLocaleString()}`;
        
        fileInfo.appendChild(fileName);
        fileInfo.appendChild(filePosition);
        fileInfo.appendChild(fileDate);
        
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-file';
        deleteBtn.textContent = 'Âà†Èô§';
        deleteBtn.onclick = (e) => {
          e.stopPropagation();
          removeFromRecentFiles(file.name);
        };
        
        fileItem.appendChild(fileInfo);
        fileItem.appendChild(deleteBtn);
        
        // ÁÇπÂáªÊñá‰ª∂È°πÂä†ËΩΩÊñá‰ª∂
        fileItem.onclick = () => {
          loadFileFromHistory(file);
        };
        
        recentFilesList.appendChild(fileItem);
      });
    }
    
    // ‰ªéÂéÜÂè≤ËÆ∞ÂΩïÂä†ËΩΩÊñá‰ª∂
    function loadFileFromHistory(fileData) {
      currentFileName = fileData.name;
      currentFileContent = fileData.content;
      sentences = fileData.content.split(/\r?\n/).filter(s => s.trim() !== '');
      currentIndex = fileData.position;
      progressRange.max = sentences.length - 1;
      progressRange.value = currentIndex;
      renderSentences();
      highlightCurrent();
      
      // Ê∏ÖÁ©∫Êñá‰ª∂ËæìÂÖ•Ê°Ü
      fileInput.value = '';
    }

    speedRange.oninput = () => readSpeed = parseFloat(speedRange.value);
    volumeRange.oninput = () => volume = parseFloat(volumeRange.value);

    fileInput.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        const text = e.target.result;
        currentFileName = file.name;
        currentFileContent = text;
        sentences = text.split(/\r?\n/).filter(s => s.trim() !== '');
        currentIndex = 0;
        progressRange.max = sentences.length - 1;
        progressRange.value = 0;
        renderSentences();
        
        // Ê∑ªÂä†Âà∞ÊúÄËøëÊñá‰ª∂ÂàóË°®
        addToRecentFiles(file.name, text, 0);
      };
      reader.readAsText(file);
    };

    function renderSentences() {
      sentenceBox.innerHTML = '';
      sentences.forEach((sentence, i) => {
        const div = document.createElement('div');
        div.className = 'sentence';
        div.textContent = sentence;
        div.dataset.index = i;
        sentenceBox.appendChild(div);
      });
    }

    function highlightCurrent() {
      document.querySelectorAll('.sentence').forEach((el, idx) => {
        el.classList.toggle('highlight', idx === currentIndex);
      });
      progressLabel.textContent = `Á¨¨ ${currentIndex} Âè•`;
      progressRange.value = currentIndex;
      const currentEl = document.querySelector(`.sentence[data-index="${currentIndex}"]`);
      if (currentEl) {
        currentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
      
      // Êõ¥Êñ∞ÂΩìÂâçÊñá‰ª∂ÁöÑÊúóËØª‰ΩçÁΩÆ
      if (currentFileName) {
        updateFilePosition(currentFileName, currentIndex);
      }
    }

    progressRange.oninput = () => {
      currentIndex = parseInt(progressRange.value);
      //reading = true;
      speechSynthesis.cancel();
      readSentence();
    };

    

    bookmarkBtn.onclick = () => {
      if (!bookmarkedIndices.includes(currentIndex)) {
        bookmarkedIndices.push(currentIndex);
        const li = document.createElement('li');
        li.textContent = `Á¨¨ ${currentIndex} Âè•Ôºö${sentences[currentIndex]}`;
        li.style.cursor = 'pointer';
        li.onclick = () => {
          currentIndex = parseInt(li.textContent.split('Âè•')[0].replace('Á¨¨', ''));
          readSentence();
        };
        bookmarkList.appendChild(li);
      }
    };

    function readSentence() {
    	let tempIdx=currentIndex;
    	if(mIndex) currentIndex=mIndex;
      if (currentIndex >= sentences.length ){mIndex=null; return;} 
      
      const utterance = new SpeechSynthesisUtterance(sentences[currentIndex]);
      currentIndex=tempIdx;
      utterance.rate = readSpeed;
      utterance.volume = volume;
      /*utterance.onend = () => {
        currentIndex++;
        highlightCurrent();
        if (reading && currentIndex < sentences.length) {
          setTimeout(() => readSentence(), 400);
        }
      };*/
      //mIndex=null;
      highlightCurrent();
      //speechSynthesis.cancel();
      //Put this on the play button
    synth.resume();
    synth.speak(utterance);
      //speechSynthesis.speak(utterance);
    }

      function startRbtn(){
      	if(mIndex)
      	 thisSentence = sentences[mIndex];

      if (!thisSentence) {
        
        return;
      }

      if (!recorder) {
        
        return;
      }

      isRecording = true;
      
      resultDiv.textContent = "üéô Ê≠£Âú®ÂΩïÈü≥ÔºåËØ∑ÊúóËØªÂè•Â≠ê...";

      recorder.record({
        serverParams: {
          coreType: "en.sent.pron",
          refText: thisSentence,
          rank: 100,
          attachAudioUrl: 1
        },
        duration: 10000, // ÊúÄÂ§ßÂΩïÈü≥Êó∂ÈïøÔºàÊØ´ÁßíÔºâ
        playDing: false, 
        onScore: result => {
         // console.log("‚úÖ ÊµãËØÑÂéüÂßã JSONÔºö", result);
         formatResult(result);
        },
        onScoreError: err => {
          console.error("‚ùå ÊµãËØÑÂ§±Ë¥•", err);
          resultDiv.textContent = "ÊµãËØÑÂ§±Ë¥•Ôºö" + JSON.stringify(err);
        },
        onStart: () => {
         console.log("üì§ ÂΩïÈü≥ÂºÄÂßãÔºåÊ≠£Âú®Â§ÑÁêÜ...");
        },
        onStop: () => {
          console.log("üì§ ÂΩïÈü≥ÁªìÊùüÔºåÊ≠£Âú®Â§ÑÁêÜ...");
        }
        });
    }
       function stopRbtn(){
       	if (isRecording && recorder) {
              recorder.stopRecord(); // ‚úÖ Ê≠£Á°ÆÁöÑÂÅúÊ≠¢ÊñπÊ≥ï
              isRecording = false;
           }
      }
    
function extractHitWordGroups(words) {
  if (!Array.isArray(words)) return [];

  // Step 1: ÊâæÂá∫ÂëΩ‰∏≠ÁöÑËØçÂèäÂÖ∂Á¥¢Âºï
  const hits = words
    .map((word, index) => {
      const isHit = word.score > 0 || (word.rec && word.rec.trim() !== "#");
      return isHit ? { index, text: word.lab } : null;
    })
    .filter(Boolean);

  if (hits.length === 0) return [];

  // Step 2: ÊåâÁ¥¢ÂºïÂàÜÁªÑËøûÁª≠ÁöÑÂëΩ‰∏≠ËØç
  const groups = [];
  let currentGroup = [hits[0]];

  for (let i = 1; i < hits.length; i++) {
    const prev = hits[i - 1];
    const curr = hits[i];
    if (curr.index === prev.index + 1) {
      currentGroup.push(curr);
    } else {
      groups.push(currentGroup);
      currentGroup = [curr];
    }
  }
  groups.push(currentGroup); // Âä†ÂÖ•ÊúÄÂêé‰∏ÄÁªÑ

  // Step 3: ËæìÂá∫ÊØèÁªÑÂëΩ‰∏≠ËØçÊñáÊú¨ÂàóË°®
  return groups.map(group => group.map(item => item.text));
}

    // Ê†ºÂºèÂåñÊµãËØÑÁªìÊûú
    function formatResult(result) {
  if (!result || !result.result || !result.result.details) {
    return "Êó†ÊúâÊïàÁªìÊûú";
  }

  const { overall, fluency, integrity, accuracy } = result.result;
  const words = result.result.details;
  const matchlist=extractHitWordGroups(words);
  let mpiece=null;
 
  if (matchlist.length===1){
  	mpiece=matchlist[0].join(" ");
  }
  if(thisSentence){
  	let queryText="";
	  if(mpiece ){
	   queryText=`ÁÆÄËø∞${mpiece}Âú®Âè•‰∏≠ÁöÑÁî®Ê≥ïÔºå${thisSentence}`;
	  }else {
	   queryText=`ËÆ≤Ëß£ËøôÂè•ËØùÔºö${thisSentence}`;
	  }
	  thisSentence=null;
	  client.sendMessage(queryText).then(result=>{
	      const utterance = new SpeechSynthesisUtterance(result);
	      
	      utterance.rate = readSpeed;
	      utterance.volume = volume;
	      synth.speak(utterance);	 
	      document.getElementById("result").textContent = result;
	  	});
    
  }

  

  

  let tableHTML = `
    <table border="1" cellpadding="6" style="margin-top:10px; border-collapse: collapse; width:100%;">
      <thead>
        <tr style="background:#eee;">
          <th>Â∫èÂè∑</th>
          <th>ÂçïËØç</th>
          <th>ÂæóÂàÜ</th>
          <th>Á∫†Ê≠£Âª∫ËÆÆ</th>
        </tr>
      </thead>
      <tbody>
  `;
words.forEach((word, index) => {
    

    tableHTML += `
      <tr>
        <td>${index + 1}</td>
        <td>${word.lab}</td>
        <td>${word.score}</td>
        <td>${word.rec || "‚Äî"}</td>
      </tr>
    `;
        
   });

  tableHTML += `</tbody></table>`;

  
  document.getElementById("wordTableContainer").innerHTML = tableHTML;

  
}     

 class XiaobaiChatClient {
  constructor(apiKey, botId = 200006, modelId = "deepseekV3_1") {
    this.apiKey = apiKey;
    this.botId = botId;
    this.modelId = modelId;
    this.deviceId = `${crypto.randomUUID().replace(/-/g, "")}_${Date.now()}_${Math.floor(Math.random() * 1000000)}`;
    this.token = "";
    this.userId = "";
    this.conversationId = "";
  }

  async generateSignature(payloadStr) {
    const mistiming = Number(localStorage.getItem("mistiming")) || 0;
    const xDate = new Date(Date.now() + mistiming).toUTCString();
    const digestBuffer = await crypto.subtle.digest("SHA-256", new TextEncoder().encode(payloadStr));
    const digestBase64 = btoa(String.fromCharCode(...new Uint8Array(digestBuffer)));
    const digestHeader = `SHA-256=${digestBase64}`;
    const stringToSign = `x-date: ${xDate}\ndigest: ${digestHeader}`;
    const keyBuffer = new TextEncoder().encode(this.apiKey);
    const cryptoKey = await crypto.subtle.importKey("raw", keyBuffer, { name: "HMAC", hash: "SHA-1" }, false, ["sign"]);
    const signatureBuffer = await crypto.subtle.sign("HMAC", cryptoKey, new TextEncoder().encode(stringToSign));
    const signatureBase64 = btoa(String.fromCharCode(...new Uint8Array(signatureBuffer)));
    const authorizationHeader = `hmac username="web.1.0.beta", algorithm="hmac-sha1", headers="x-date digest", signature="${signatureBase64}"`;

    return { xDate, digestHeader, authorizationHeader };
  }

  async init() {
    const payload = {
      deviceId: this.deviceId,
      device: "Edge",
      client: "tourist",
      phone: this.deviceId,
      code: this.deviceId,
      extraInfo: { url: "https://www.wenxiaobai.com/" }
    };
    const payloadStr = JSON.stringify(payload);
    const { xDate, digestHeader, authorizationHeader } = await this.generateSignature(payloadStr);

    const headers = {
      "Content-Type": "application/json",
      "Authorization": authorizationHeader,
      "Digest": digestHeader,
      "x-date": xDate,
      "X-Yuanshi-AppName": "wenxiaobai",
      "X-Yuanshi-DeviceId": this.deviceId,
      "X-Yuanshi-Platform": "web"
    };

    const res = await fetch("https://api-bj.wenxiaobai.com/api/v1.0/user/sessions", {
      method: "POST",
      headers,
      body: payloadStr
    });
    const data = await res.json();
    this.token = data?.data?.token || "";
    this.userId = data?.data?.user?.id || "";

    await this.createConversation();
  }

  async createConversation() {
    const url = `https://api-bj.wenxiaobai.com/api/v1.0/core/conversations/users/${this.userId}/bots/${this.botId}/conversation`;
    const payloadStr = JSON.stringify({ visitorId: this.deviceId });
    const { xDate, digestHeader, authorizationHeader } = await this.generateSignature(payloadStr);

    const headers = {
      "Content-Type": "application/json",
      "Authorization": authorizationHeader,
      "Digest": digestHeader,
      "x-date": xDate,
      "X-Yuanshi-Authorization": `Bearer ${this.token}`,
      "X-Yuanshi-AppName": "wenxiaobai",
      "X-Yuanshi-DeviceId": this.deviceId,
      "X-Yuanshi-Platform": "web"
    };

    const res = await fetch(url, {
      method: "POST",
      headers,
      body: payloadStr
    });
    const data = await res.json();
    this.conversationId = data?.data || "";
  }

  async sendMessage(query) {
    const body = {
      userId: this.userId,
      botAlias: "custom",
      query,
      isRetry: false,
      breakingStrategy: 0,
      isNewConversation: true,
      isAnonymousChat: false,
      mediaInfos: [],
      turnIndex: 0,
      rewriteQuery: "",
      conversationId: this.conversationId,
      attachmentInfo: { url: { infoList: [] } },
      inputWay: "proactive",
      agentId: this.botId,
      modelId: this.modelId,
      aiAbility: { id: "" },
      abilities: [],
      pureQuery: "",
      isPublic: 0
    };
    const payloadStr = JSON.stringify(body);
    const { xDate, digestHeader, authorizationHeader } = await this.generateSignature(payloadStr);

    const headers = {
      "Content-Type": "application/json",
      "Accept": "text/event-stream, application/json, text/event-stream",
      "Authorization": authorizationHeader,
      "Digest": digestHeader,
      "x-date": xDate,
      "X-Yuanshi-AppName": "wenxiaobai",
      "X-Yuanshi-Authorization": `Bearer ${this.token}`,
      "X-Yuanshi-DeviceId": this.deviceId,
      "X-Yuanshi-Platform": "web"
    };

    const res = await fetch("https://api-bj.wenxiaobai.com/api/v1.0/core/conversation/chat/v3", {
      method: "POST",
      headers,
      body: payloadStr
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder("utf-8");
    let finalText = "";
    let isThinking = false;
    let counter=0;
    while (counter<=3) {
      const { done, value } = await reader.read();
      if (done) break;
      const chunk = decoder.decode(value, { stream: true });
      const lines = chunk.split("\n").map(line => line.trim()).filter(Boolean);
      for (const line of lines) {
      	if(counter>3) break;
        const content = this.extractContent(line);
        if (content && typeof content === 'string') {
          if (content.startsWith("```ys_think")) {
            isThinking = true;
          } else if (content.includes("\n<end>Â∑≤Ê∑±Â∫¶ÊÄùËÄÉ")) {
            isThinking = false;
          } else if (!isThinking) {
          	counter+=1;
            finalText += content;
          }
        }
      }
    }

    return this.md2tts(finalText);
  }

  extractContent(line) {
    const raw = line.startsWith("data:") ? line.slice(5).trim() : line.trim();
    try {
      const json = JSON.parse(raw);
      return json?.content || null;
    } catch {
      const match = raw.match(/"content"\s*:\s*"([^"]*)/);
      return match ? match[1] : null;
    }
  }

  md2tts(md) {
    const html = marked.parse(md);
    const div = document.createElement("div");
    div.innerHTML = html;
    div.querySelectorAll("script,style,noscript,svg,canvas").forEach(n => n.remove());
    div.querySelectorAll("pre,code").forEach(n => n.innerText = n.innerText.replace(/\n+/g, " "));
    div.querySelectorAll("table").forEach(table => {
      const lines = Array.from(table.rows).map(row =>
        Array.from(row.cells).map(cell => cell.innerText.trim()).join("Ôºå")
      );
      table.replaceWith(lines.join("Ôºõ"));
    });
    div.querySelectorAll("img").forEach(img => img.replaceWith(img.alt ? `[${img.alt}]` : ""));
    div.querySelectorAll("a").forEach(a => a.replaceWith(a.innerText));
    return div.innerText.replace(/\s+/g, " ").replace(/([„ÄÇÔºÅÔºüÔºõÔºå\.])\s*([„ÄÇÔºÅÔºüÔºõÔºå\.])/g, "$1").trim();
  }
}
      

        
      

    document.addEventListener('keyup', (e) => {
      if (e.key === '0') {
        const now = Date.now();
        lastKeyTime=now;
        const pressDuration = now - keyDownTime;
        

        if(longPressTimer) clearTimeout(longPressTimer);
        longPressTimer=null;

        if (!isLongPress && pressDuration < longPressThreshold) {
          if (!speechSynthesis.speaking ) {
			//reading = true;
			  speechSynthesis.cancel();
			  mIndex=null;
			  readSentence();
		   } else {
		//	reading = false;
		    synth.pause();
		    return; // ÁâπÊÆäÂ§ÑÁêÜÂÆåÂ∞±ËøîÂõûÔºå‰∏çËß¶ÂèëÊúóËØªÈÄªËæë
		   }
        }else{
        	isLongPress = false;
        	stopRbtn();
        }
       
      }
    });    
		
document.addEventListener('keydown',  (e)=> {
  if (e.repeat) return;

    const now = Date.now();
      if (now - lastKeyTime < debounceDelay) return;
         lastKeyTime = now;
  if (!sentences.length) return;
  switch (e.key) {
    case 'Enter': 
      e.preventDefault(); // Â¶ÇÊûú‰Ω†‰∏çÂ∏åÊúõËß¶ÂèëÈªòËÆ§Ë°å‰∏∫ÔºàÂ¶ÇÊèê‰∫§Ë°®ÂçïÔºâ
      mIndex=null;
      currentIndex = Math.min(sentences.length - 1, currentIndex + 2);
      
      break;
  
    case '1':
      mIndex = Math.min(sentences.length - 1, currentIndex + 1);
      break;
    case '2':
      mIndex = Math.max(0, currentIndex - 1);
      break;
    case '3':
      mIndex = Math.max(0, currentIndex - 2);
      break;
    case '.':
      mIndex=null;
      currentIndex = Math.max(0, currentIndex - 1);
      break;
    case '0':
      e.preventDefault(); // Èò≤Ê≠¢È°µÈù¢ÊªöÂä®
      keyDownTime = now;
      if(isLongPress ===false && longPressTimer===null){
	      longPressTimer = setTimeout(() => {
	        	synth.pause();
	              isLongPress = true;
	        	  startRbtn(); //ÂºÄÂßãÂΩïÈü≥
	            
	          
	        }, longPressThreshold);
      }

	  return;

      
    default:
      return; // ÈùûÊåáÂÆöÈîÆ‰∏çÂ§ÑÁêÜ
  }

//  reading = true;
  speechSynthesis.cancel();
  readSentence();
});

    // È°µÈù¢ÂàùÂßãÂåñ
    window.addEventListener('load', () => {
      // Ê£ÄÊü•ÊµèËßàÂô®ÊòØÂê¶ÊîØÊåÅ Service Worker
	    if ('serviceWorker' in navigator) {
	      navigator.serviceWorker.register('sw.js')
	      .then(registration => {
	        console.log('Service Worker Ê≥®ÂÜåÊàêÂäü:', registration);
	      })
	      .catch(error => {
	        console.error('Service Worker Ê≥®ÂÜåÂ§±Ë¥•:', error);
	      });
		  } else {
		    console.warn('ÂΩìÂâçÊµèËßàÂô®‰∏çÊîØÊåÅ Service Worker');
		  }
	      // Ê∏≤ÊüìÊúÄËøëÊñá‰ª∂ÂàóË°®
	      renderRecentFiles();
	      // È°µÈù¢Âä†ËΩΩÊó∂ÂàùÂßãÂåñ SDK
	     initRecorder();
	
		 client = new XiaobaiChatClient("TkoWuEN8cpDJubb7Zfwxln16NQDZIc8z");
		
		 client
              .init()
               .then(()=>console.log("xbÂàùÂßãÂåñÂÆåÊàê"))
               .catch(e=>console.log ("xbÂàùÂßãÂåñÂ§±Ë¥•Ôºö",e));


    });

    

  </script>
</body>
</html>
